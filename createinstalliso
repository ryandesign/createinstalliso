#!/bin/zsh

# Copyright (c) 2020 Ryan Schmidt
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to
# deal in the Software without restriction, including without limitation the
# rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
# sell copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
# FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
# IN THE SOFTWARE.
#
# Creates an ISO file from a macOS Install app or InstallESD.dmg, especially
# for use with VMware.
#
# TODO: Support High Sierra and later (BaseSystem.dmg next to InstallESD.dmg)
# TODO: Allow an InstallOS.pkg or InstallMacOSX.pkg to be specified
# TODO: Allow a dmg containing an install pkg or app to be specified

set -euo pipefail

scriptname=${0##*/}

usage() {
    printf "usage: %s [ Install macOS XXX.app | InstallESD.dmg ]\n" $scriptname
    exit
}

err() {
    local errmsg=$1
    local exitcode=${2-1}
    printf "%s: %s\n" $scriptname $errmsg 1>&2
    exit $exitcode
}

# Based on vercomp by Paused until further notice but updated with zsh compatibility
# https://stackoverflow.com/questions/4023830/how-to-compare-two-strings-in-dot-separated-version-format-in-bash
vercomp() {
    [[ $1 == $2 ]] && return 0
    local i n num1 num2 ver1 ver2 IFS=.
    if [[ -n ${ZSH_VERSION-} ]]; then
        ver1=(${=1}) ver2=(${=2})
    else
        ver1=($1) ver2=($2)
    fi
    if ((${#ver1[@]} > ${#ver2[@]})); then
        n=${#ver1[@]}
    else
        n=${#ver2[@]}
    fi
    for ((i=0; i<n; i++)); do
        num1=$((10#${ver1[@]:$i:1}))
        num2=$((10#${ver2[@]:$i:1}))
        ((num1 > num2)) && return 1
        ((num1 < num2)) && return 2
    done
    return 0
}

versiontest() {
    local op
    vercomp $1 $3
    case $? in
        0) op="=";;
        1) op=">";;
        2) op="<";;
    esac
    [[ $op == $2 ]]
}

(($# > 0)) || usage

input=$1

if [[ ${input##*.} = "dmg" ]]; then
    esddmg=$input
else
    esddmg=$input/Contents/SharedSupport/InstallESD.dmg
fi

[[ -f $esddmg ]] || usage

#command -v unbuffer > /dev/null || err "unbuffer is required. You can install it with MacPorts: sudo port install expect"

command -v rsync > /dev/null || err "rsync 3.1.0 or later is required. You can install it with MacPorts: sudo port install rsync"

rsyncversion=$(rsync --version | sed -En '1s/^rsync  version ([^ ]+).*$/\1/p')
versiontest $rsyncversion "<" "3.1" && err "rsync 3.1.0 or later is required. You can install it with MacPorts: sudo port install rsync"

#(( $UID == 0 )) || exec sudo $0 "$@"
#origuid=${SUDO_UID:-$UID}
#origgid=${SUDO_GID:-$GID}

: ${TMPDIR=/tmp}

plistbuddy=/usr/libexec/PlistBuddy

lastprog=1

printprog() {
    printf "%.2f " $lastprog
    echo "$@"
}

scaleprog() {
    local msg=$1
    local scaledmin=$lastprog
    local scaledmax=${2-$scaledmin}
    local scaledrange=$((scaledmax - scaledmin))
    local unscaledmax=${3-100}
    printprog $msg
    while IFS= read -r line; do
        [[ -z $line ]] && continue
        unscaledprog=${line%% *}
        lastprog=$(echo "scale=2; $scaledmin + $scaledrange * ($unscaledprog / $unscaledmax)" | bc)
        printprog ${line:$(($#unscaledprog+1))}
    done
    lastprog=$scaledmax
}

cleanup() {
    printprog "Cleaning up"

    [[ -d $mount ]] && hdiutil detach $mount
    #[[ -d $basemount ]] && hdiutil detach $basemount
    [[ -d $esdmount ]] && hdiutil detach $esdmount

#    sudo chown -R $origuid:$origgid $builddir

#    rm -rf $builddir
}

traphandler() {
    cleanup
    trap - EXIT
    exit 0
}

trap 'traphandler' EXIT INT TERM

builddir=$(mktemp -d $TMPDIR/$scriptname.XXXXXX)
plist=$builddir/tmp.plist
esdshadow=$builddir/esdshadow
esdmount=$builddir/esd

printprog "Mounting electronic software distribution image"
#hdiutil attach $esddmg -mountpoint $esdmount -nobrowse -puppetstrings -shadow $esdshadow | unbuffer -p sed -En 's/^PERCENT:([0-9.]+).*$/\1/p' | scaleprog "Mounting electronic software distribution image" 0 100
#script -q /dev/null
hdiutil attach $esddmg -mountpoint $esdmount -nobrowse -puppetstrings -shadow $esdshadow | sed -Eln 's/^PERCENT:([0-9.]+).*$/\1/p' | scaleprog "Mounting electronic software distribution image" 5

if [[ -f $esdmount/boot.efi ]]; then
    shadow=$esdshadow
    mount=$esdmount
    dmg=$esddmg

    diskutil info -plist $mount > $plist
    dev=$($plistbuddy $plist -c 'Print :DeviceNode')
else
    shadow=$builddir/baseshadow
    mount=$builddir/basesystem
    dmg=$(dirname $esddmg)/BaseSystem.dmg
    [[ -f $dmg ]] || dmg=$esdmount/BaseSystem.dmg
    basedmgsize=$(hdiutil resize -limits $dmg | awk '{print int($2/2)+1}')
    filessize=$(du -cks $esdmount/{BaseSystem.*,Packages} | tail -n1 | cut -d$'\t' -f1)
    dmgsize=$((basedmgsize + filessize))

    printprog "Resizing base system image"
    hdiutil resize -shadow $shadow -size ${dmgsize}k $dmg

    printprog "Mounting base system image"
#    hdiutil attach $dmg -mountpoint $mount -nobrowse -puppetstrings -shadow $shadow | unbuffer -p sed -En 's/^PERCENT:([0-9.]+).*$/\1/p' | scaleprog "Mounting base system image" 0 100
#script -q /dev/null
    hdiutil attach $dmg -mountpoint $mount -nobrowse -puppetstrings -shadow $shadow | sed -Eln 's/^PERCENT:([0-9.]+).*$/\1/p' | scaleprog "Mounting base system image" 10

    diskutil info -plist $mount > $plist
    dev=$($plistbuddy $plist -c 'Print :DeviceNode')

    printprog "Copying packages and other files"
#    rsync -a --info=progress2 $esdmount/ --include='BaseSystem.*' --include='Packages/***' --exclude='*' $mount | unbuffer -p tr '\r' '\n' | unbuffer -p sed -En 's/^ *[^ ]+ +([0-9]+).*$/\1/p' | scaleprog "Copying packages and other files" 0 100
#script -q /dev/null
    rsync -a --info=progress2 $esdmount/ --include='BaseSystem.*' --include='Packages/***' --exclude='*' $mount | tr -u '\r' '\n' | sed -Eln 's/^ *[^ ]+ +([0-9]+).*$/\1/p' | scaleprog "Copying packages and other files" 50
    rm -f $mount/System/Installation/Packages
    mv $mount/Packages $mount/System/Installation/
fi

systemversionplist=$mount/System/Library/CoreServices/SystemVersion.plist
osversion=$($plistbuddy $systemversionplist -c 'Print :ProductVersion')
osbuild=$($plistbuddy $systemversionplist -c 'Print :ProductBuildVersion')
appdisplayname=$($plistbuddy $mount/Install\ *.app/Contents/Info.plist -c 'Print :CFBundleDisplayName')
installername="$appdisplayname $osversion $osbuild"

diskutil rename $dev $installername
diskutil info -plist $dev > $plist
mount=$($plistbuddy $plist -c 'Print :MountPoint')

find $mount -depth 1 \! -name $appdisplayname.app -print0 | xargs -0 chflags -h hidden

printprog "Unmounting image"
iso=$builddir/$installername.iso
hdiutil detach $mount
printprog "Creating ISO image"
#sudo COLUMNS=100 hdiutil makehybrid -o $iso $mount/ | unbuffer -p tr '.' '\n' | unbuffer -p awk 'BEGIN {n=1} /^$/ {print n++}' | scaleprog "Creating ISO image" 0 100

sudo script -q /dev/null hdiutil makehybrid -o $iso -shadow $shadow $dmg | tr -u '.' '\n' | awk 'BEGIN {n=1} /^$/ {print n++; fflush()}' | scaleprog "Creating ISO image" 100 $COLUMNS
