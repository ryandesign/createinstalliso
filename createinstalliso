#!/bin/bash

# Copyright (c) 2020 Ryan Schmidt
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to
# deal in the Software without restriction, including without limitation the
# rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
# sell copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
# FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
# IN THE SOFTWARE.
#
# Creates an ISO file from a macOS Install app, especially for use with VMware.
#
# Adapted from:
# https://tylermade.net/2017/10/05/how-to-create-a-bootable-iso-image-of-macos-10-13-high-sierra-installer/

set -euxo pipefail

scriptname=$(basename "$0")

if [ $# -eq 0 ]; then
    printf "usage: %s '/path/to/Install macOS Whatever.app'\n" "$scriptname"
    exit
fi

err() {
    local errmsg="$1"
    local exitcode="${2-1}"
    printf "%s: %s\n" "$scriptname" "$errmsg" 1>&2
    exit "$exitcode"
}

diskutilerr() {
    local errmsg=$("$plistbuddy" -c "Print :ErrorMessage" "$plist")
    local exitcode=$("$plistbuddy" -c "Print :ExitCode" "$plist")
    err "$errmsg" "$exitcode"
}

# vercomp by Paused until further notice
# https://stackoverflow.com/questions/4023830/how-to-compare-two-strings-in-dot-separated-version-format-in-bash
vercomp() {
    if [[ $1 == $2 ]]; then
        return 0
    fi
    local IFS=.
    local i ver1=($1) ver2=($2)
    # fill empty fields in ver1 with zeros
    for ((i=${#ver1[@]}; i<${#ver2[@]}; i++)); do
        ver1[i]=0
    done
    for ((i=0; i<${#ver1[@]}; i++)); do
        if [[ -z ${ver2[i]} ]]; then
            # fill empty fields in ver2 with zeros
            ver2[i]=0
        fi
        if ((10#${ver1[i]} > 10#${ver2[i]})); then
            return 1
        fi
        if ((10#${ver1[i]} < 10#${ver2[i]})); then
            return 2
        fi
    done
    return 0
}

versiontest() {
    vercomp "$1" "$3"
    case $? in
        0) op="=";;
        1) op=">";;
        2) op="<";;
    esac
    [ "$op" == "$2" ]
}

apppath="$1"

[ -e "$apppath" ] || err "'$apppath' does not exist"
[ -e "$apppath/Contents/SharedSupport" ] || err "'$apppath/Contents/SharedSupport' does not exist"

: "${TMPDIR=/tmp}"

# Authenticate early, before starting time-consuming operations.
sudo printf ""

plistbuddy=/usr/libexec/PlistBuddy

appname=$(basename "$apppath" .app)
appver=$($plistbuddy -c "Print :CFBundleShortVersionString" "$apppath"/Contents/Info.plist)

#imgname="$appname $osver $appver"
imgname="$appname $appver"
iso="$imgname".iso
[ -f "$iso" ] && err "'$iso' already exists"

workdir=$(mktemp -d "$TMPDIR"/"$scriptname".XXXXXX)
#trap 'rm -rf -- "$workdir"' EXIT
trap 'open -- "$workdir"' EXIT
plist="$workdir"/disk.plist

iso="$workdir"/"$iso"

datasize=$(du -sk "$apppath"/Contents/SharedSupport | cut -d $'\t' -f 1)
imgsize=$(printf "1.2 * %s / 1\n" "$datasize" | bc)

# Install OS X Mountain Lion and earlier didn't have createinstallmedia
#if [[ "$appvermajor" -lt 1 || ("$appvermajor" -eq 1 && ("$appverminor" -lt 3 || "$appverminor" -eq 3 && "$appverpatch" -lt 30)) ]]; then
if versiontest "$appver" "<" "1.3.30"; then
    # Can we just convert the ESD image directly?
    tmpimg="$apppath"/Contents/SharedSupport/InstallESD.dmg
else
    # Create a sufficiently large temporary image.
    tmpimg="$workdir"/"$imgname".sparsebundle
    hdiutil create -o "$tmpimg" -size "$imgsize"k -layout ISOCD -fs HFS+J
    mountpoint=/Volumes/"$imgname.$$"

    # Mount the temporary image, hiding it somewhat.
    hdiutil attach "$tmpimg" -mountpoint "$mountpoint" -nobrowse -noverify -plist > "$plist"

    # Find the image's whole-disk device number.
    n=0
    while
        device=$("$plistbuddy" -c "Print :system-entities:$n:dev-entry" "$plist")
        tmpcontenthint=$("$plistbuddy" -c "Print :system-entities:$n:content-hint" "$plist" 2>/dev/null)
        [ "$tmpcontenthint" != "Apple_partition_scheme" ]
    do
        n=$((n + 1))
    done

    # Work around a bug in the reissued macOS Sierra installer. See
    # https://forums.macrumors.com/threads/not-a-valid-volume-mount-point-cant-make-bootable-drive.1935673/page-3?post=28197924#post-28197924
    # https://ericfromcanada.github.io/output/2020/multi-macos-install-drive-diskmaker.html
    # https://feedbackassistant.apple.com/feedback/7628029
    if [ "$appver" == "12.6.06" ]; then
        sudo plutil -replace CFBundleShortVersionString -string "12.6.03" "$apppath/Contents/Info.plist"
    fi

    # Create a bootable installer on the image.
    args=()
    if versiontest "$appver" "<" "13"; then
        args+=( --applicationpath "$apppath" )
    fi
    args+=( --nointeraction --volume "$mountpoint" )
    (cd "$apppath"/Contents/Resources && sudo ./createinstallmedia "${args[@]}")

    # Find the new volume name that createinstallmedia assigned.
    diskutil list -plist "$device" > "$plist" || diskutilerr
    volname=$("$plistbuddy" -c "Print :VolumesFromDisks:0" "$plist")
    mountpoint=/Volumes/"$volname"

    # If we worked around the reissued macOS Sierra installer bug, undo the
    # workaround.
    if [ "$appver" == "12.6.06" ]; then
        sudo plutil -replace CFBundleShortVersionString -string "$appver" "$apppath/Contents/Info.plist"
        sudo plutil -replace CFBundleShortVersionString -string "$appver" "$mountpoint/$(basename "$apppath")/Contents/Info.plist"
    fi

    # Find the new device number that got assigned.
    #n=0
    #while
    #    device=$("$plistbuddy" -c "Print :AllDisksAndPartitions:0:Partitions:$n:DeviceIdentifier" "$plist")
    #    tmpvolname=$("$plistbuddy" -c "Print :AllDisksAndPartitions:0:Partitions:$n:VolumeName" "$plist")
    #    [ "$tmpvolname" != "$volname" ]
    #do
    #    n=$((n + 1))
    #done

    # Find out how much space is used on the disk. This seems to change slightly
    # shortly after creation (maybe Spotlight indexing?), so wait until it settles
    # down.
    #n=0
    #lastsize=0
    #while [ "$n" -lt 30 ]; do
    #    diskutil resizeVolume "$device" limits -plist > "$plist" || diskutilerr
    #    usedsize=$("$plistbuddy" -c "Print :MinimumSizeNoGuard" "$plist")
    #    if [ "$usedsize" -eq "$lastsize" ]; then
    #        n=$((n + 1))
    #    else
    #        n=0
    #        lastsize="$usedsize"
    #    fi
    #    sleep 2
    #done

    # Resize the volume so there is no empty space.
    #diskutil resizeVolume "$device" "$usedsize"

    # Unmount the volume but leave the image attached.
    #hdiutil unmount "$device"

    # Create an ISO from just the installer partition.
    #hdiutil create -o "$cdr" -format UDTO -srcdevice "$device"
    #mv "$cdr" "$iso"

    # Detach the image.
    hdiutil detach "$device"
fi

# Create a read-only ISO.
hdiutil makehybrid -o "$iso" "$tmpimg"
mv "$iso" .

# Detach the image.
#hdiutil detach "$device"
